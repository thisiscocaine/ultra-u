<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="https://cdn.aryanaryal.com.np/626c6f672d617279616e/70686f746f73/6c6f676f73/favicon.png" type="image/x-icon">
    <title>universe</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at center, #020111 0%, #020111 45%, #191528 80%, #3a3e52 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Arial', sans-serif;
            touch-action: manipulation;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .title {
            position: absolute;
            color: rgba(255, 255, 255, 0.9);
            font-size: clamp(1.5rem, 4vw, 3rem);
            text-align: center;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
            z-index: 100;
            top: 20px;
            width: 100%;
            animation: pulse 4s infinite alternate;
            pointer-events: none;
        }
        @keyframes pulse {
            0% { 
                opacity: 0.7;
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            }
            100% { 
                opacity: 1;
                text-shadow: 0 0 20px rgba(255, 255, 255, 0.9), 
                             0 0 30px rgba(100, 150, 255, 0.7);
            }
        }
        .loading {
            position: absolute;
            color: white;
            font-size: 1.2rem;
            z-index: 101;
            text-align: center;
            width: 100%;
            top: 50%;
            transform: translateY(-50%);
        }


 /* Responsive Breakpoints */
        
        /* Small tablets (portrait) */
        @media (min-width: 600px) {
            .title {
                font-size: 1.8rem;
            }
            
            /* Adjust galaxy density for medium screens */
            body::after {
                content: "";
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                background: radial-gradient(circle at center, transparent 60%, rgba(0,0,10,0.3) 100%);
            }
        }
        
        /* Tablets (landscape) and small laptops */
        @media (min-width: 768px) and (orientation: landscape) {
            .title {
                font-size: 2rem;
            }
            
            /* Enhance visual elements for larger screens */
            body {
                background: radial-gradient(ellipse at center, #020111 0%, #020111 40%, #191528 75%, #3a3e52 100%);
            }
        }
        
        /* Standard laptops and desktops */
        @media (min-width: 992px) {
            .title {
                font-size: 2.5rem;
            }
            
            /* Add more stars and details for larger screens */
            body::before {
                content: "";
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%"><filter id="noise"><feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="4" stitchTiles="stitch"/><feColorMatrix type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.02 0"/></filter><rect width="100%" height="100%" filter="url(%23noise)"/></svg>');
                opacity: 0.15;
            }
        }
        
        /* Large desktops and high-res displays */
        @media (min-width: 1200px) {
            .title {
                font-size: 3rem;
            }
            
            /* Ultra HD optimizations */
            body {
                background: radial-gradient(ellipse at center, #020111 0%, #020111 35%, #191528 70%, #3a3e52 100%);
            }
        }
        
        /* Mobile landscape orientation */
        @media (max-height: 500px) and (orientation: landscape) {
            .title {
                font-size: 1.2rem;
                top: 10px;
            }
            
            /* Adjust layout for short screens */
            body {
                background: radial-gradient(ellipse at center, #020111 0%, #020111 50%, #191528 85%, #3a3e52 100%);
            }
        }
        
        /* High DPI displays */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            canvas {
                image-rendering: crisp-edges;
            }
        }
    </style>

    </style>
</head>
<body>
     
    <canvas id="universeCanvas"></canvas>

    <script>
        // Start the universe immediately
        document.addEventListener('DOMContentLoaded', () => {
            const loadingElement = document.getElementById('loading');
            if (loadingElement) {
                loadingElement.style.display = 'none';
            }
            initUniverse();
        });

        function initUniverse() {
            const canvas = document.getElementById("universeCanvas");
            const ctx = canvas.getContext("2d", { alpha: false });
            
            // Performance optimization
            const now = performance.now.bind(performance);
            let lastTime = 0;
            const fps = 60;
            const fpsInterval = 1000 / fps;
            
            // High DPI display support
            let dpr = window.devicePixelRatio || 1;
            
            function resizeCanvas() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                // Set display size (css pixels)
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                
                // Set actual size in memory (scaled to account for extra pixel density)
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                
                // Normalize coordinate system to use css pixels
                ctx.scale(dpr, dpr);
            }
            resizeCanvas();
            
            // Galaxy parameters with more vibrant colors
            const galaxy = {
                arms: 5,
                starsPerArm: 600,
                coreRadius: 80,
                armWidth: 0.7,
                rotationSpeed: 0.00008,
                angle: 0,
                coreColor: { r: 255, g: 100, b: 150 },
                armColors: [
                    { r: 100, g: 150, b: 255 },  // Blue arm
                    { r: 255, g: 100, b: 200 },  // Pink arm
                    { r: 100, g: 255, b: 150 },  // Green arm
                    { r: 255, g: 200, b: 100 },  // Yellow arm
                    { r: 200, g: 100, b: 255 }   // Purple arm
                ]
            };

            // Create cosmic elements
            const stars = [];
            const shootingStars = [];
            const nebulas = [];
            const numNebulas = 8;
            const dustParticles = [];
            const numDustParticles = 2000;
            
            // Improved star class with more vibrant colors
            class Star {
                constructor() {
                    const arm = Math.floor(Math.random() * galaxy.arms);
                    const distance = Math.random() * Math.min(canvas.width, canvas.height) * 0.45;
                    const angle = arm * (2 * Math.PI / galaxy.arms) + 
                                   (Math.random() * galaxy.armWidth - galaxy.armWidth/2) + 
                                   distance * 0.008;
                    
                    this.x = canvas.width/2 + distance * Math.cos(angle);
                    this.y = canvas.height/2 + distance * Math.sin(angle);
                    this.size = Math.random() * 3;
                    this.baseSize = this.size;
                    this.opacity = Math.random() * 0.8 + 0.2;
                    this.baseOpacity = this.opacity;
                    this.twinkleSpeed = Math.random() * 0.02 + 0.01;
                    this.originalX = this.x - canvas.width/2;
                    this.originalY = this.y - canvas.height/2;
                    this.arm = arm;
                    this.distanceFromCore = distance;
                    this.color = this.getStarColor();
                    this.pulseFactor = Math.random() * 0.5 + 0.5;
                }

                getStarColor() {
                    // Stars get more colorful farther from the core
                    const coreFactor = Math.min(1, this.distanceFromCore / (Math.min(canvas.width, canvas.height) * 0.45));
                    const armColor = galaxy.armColors[this.arm];
                    
                    // Core stars are more white/yellow
                    if (this.distanceFromCore < galaxy.coreRadius * 2) {
                        const r = 255;
                        const g = 255 - Math.random() * 50;
                        const b = 200 - Math.random() * 100;
                        return `rgba(${r}, ${g}, ${b}, ${this.opacity})`;
                    }
                    
                    // Arm stars take color from their arm
                    const r = armColor.r + (255 - armColor.r) * (1 - coreFactor);
                    const g = armColor.g + (255 - armColor.g) * (1 - coreFactor);
                    const b = armColor.b + (255 - armColor.b) * (1 - coreFactor);
                    
                    return `rgba(${r}, ${g}, ${b}, ${this.opacity})`;
                }

                twinkle() {
                    // More organic twinkling with pulsing
                    const timeFactor = now() * 0.001;
                    this.opacity = this.baseOpacity * (0.8 + 0.2 * Math.sin(timeFactor * this.twinkleSpeed * this.pulseFactor));
                    this.size = this.baseSize * (0.9 + 0.1 * Math.cos(timeFactor * this.twinkleSpeed * this.pulseFactor * 1.3));
                }

                update() {
                    // Rotate with galaxy (speed decreases with distance)
                    const speedFactor = 1 - (this.distanceFromCore / (Math.min(canvas.width, canvas.height) * 0.45) * 0.7);
                    const angle = Math.atan2(this.originalY, this.originalX) + galaxy.rotationSpeed * speedFactor;
                    const distance = Math.sqrt(this.originalX*this.originalX + this.originalY*this.originalY);
                    this.originalX = distance * Math.cos(angle);
                    this.originalY = distance * Math.sin(angle);
                    
                    this.x = canvas.width/2 + this.originalX;
                    this.y = canvas.height/2 + this.originalY;
                    
                    this.twinkle();
                }

                draw() {
                    ctx.globalAlpha = this.opacity;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add glow for brighter stars
                    if (this.size > 1.2) {
                        const glowSize = this.size * (2 + Math.sin(now() * 0.001) * 0.5);
                        const glowOpacity = this.opacity * 0.3;
                        
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                        ctx.fillStyle = this.color.replace(/[\d\.]+\)$/, `${glowOpacity})`);
                        ctx.fill();
                    }
                }
            }

            // Enhanced shooting star with trail effect
            class ShootingStar {
                constructor() {
                    this.reset();
                    this.speed = 3 + Math.random() * 4;
                    this.trail = [];
                    this.maxTrailLength = 15;
                }
                
                reset() {
                    this.x = Math.random() * canvas.width;
                    this.y = -20;
                    this.size = 1 + Math.random() * 2;
                    this.length = 30 + Math.random() * 70;
                    this.angle = Math.PI/4 + (Math.random() * Math.PI/8);
                    this.life = 150 + Math.random() * 150;
                    this.maxLife = this.life;
                    this.speedX = Math.cos(this.angle) * this.speed;
                    this.speedY = Math.sin(this.angle) * this.speed;
                    this.trail = [];
                    this.color = `hsl(${Math.random() * 60 + 10}, 100%, 80%)`;
                }
                
                update() {
                    this.x += this.speedX;
                    this.y += this.speedY;
                    this.life--;
                    
                    // Add current position to trail
                    this.trail.push({ x: this.x, y: this.y });
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                    
                    if (this.life <= 0 || 
                        this.x < -50 || this.x > canvas.width + 50 || 
                        this.y < -50 || this.y > canvas.height + 50) {
                        this.reset();
                    }
                }
                
                draw() {
                    const alpha = this.life / this.maxLife;
                    
                    // Draw trail
                    ctx.lineCap = 'round';
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const segmentAlpha = alpha * (i / this.trail.length);
                        ctx.strokeStyle = `${this.color.replace(')', `, ${segmentAlpha})`)}`;
                        ctx.lineWidth = this.size * (i / this.trail.length);
                        
                        ctx.beginPath();
                        ctx.moveTo(this.trail[i].x, this.trail[i].y);
                        ctx.lineTo(this.trail[i+1].x, this.trail[i+1].y);
                        ctx.stroke();
                    }
                    
                    // Draw head
                    ctx.fillStyle = `${this.color.replace(')', `, ${alpha})`)}`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Glow at head
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * 4, 0, Math.PI * 2);
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.size * 4
                    );
                    gradient.addColorStop(0, `${this.color.replace(')', `, ${alpha})`)}`);
                    gradient.addColorStop(1, `${this.color.replace(')', `, 0)`)}`);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                }
            }

            // More vibrant nebula with dynamic colors
            class Nebula {
                constructor() {
                    this.reset();
                    this.pulseSpeed = Math.random() * 0.002 + 0.001;
                    this.rotationSpeed = (Math.random() - 0.5) * 0.002;
                    this.angle = 0;
                }
                
                reset() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.size = 150 + Math.random() * 300;
                    this.baseSize = this.size;
                    this.speedX = (Math.random() - 0.5) * 0.08;
                    this.speedY = (Math.random() - 0.5) * 0.08;
                    this.color = this.getRandomColor();
                    this.seed = Math.random() * 1000;
                }
                
                getRandomColor() {
                    const types = [
                        { // Purple/blue
                            inner: { r: 150, g: 50, b: 255 },
                            outer: { r: 50, g: 100, b: 255 }
                        },
                        { // Pink/red
                            inner: { r: 255, g: 50, b: 150 },
                            outer: { r: 255, g: 100, b: 100 }
                        },
                        { // Blue/green
                            inner: { r: 50, g: 150, b: 255 },
                            outer: { r: 100, g: 255, b: 200 }
                        },
                        { // Orange/yellow
                            inner: { r: 255, g: 150, b: 50 },
                            outer: { r: 255, g: 200, b: 100 }
                        }
                    ];
                    
                    const type = types[Math.floor(Math.random() * types.length)];
                    const mix = Math.random();
                    
                    return {
                        inner: `rgba(${type.inner.r}, ${type.inner.g}, ${type.inner.b}, 0.1)`,
                        outer: `rgba(${type.outer.r}, ${type.outer.g}, ${type.outer.b}, 0.05)`,
                        highlight: `rgba(${
                            type.inner.r * 0.7 + type.outer.r * 0.3
                        }, ${
                            type.inner.g * 0.7 + type.outer.g * 0.3
                        }, ${
                            type.inner.b * 0.7 + type.outer.b * 0.3
                        }, 0.15)`
                    };
                }
                
                update() {
                    this.x += this.speedX;
                    this.y += this.speedY;
                    this.angle += this.rotationSpeed;
                    
                    // Pulsing size
                    this.size = this.baseSize * (0.9 + 0.1 * Math.sin(now() * this.pulseSpeed + this.seed));
                    
                    // Wrap around screen
                    if (this.x < -this.size * 1.5) this.x = canvas.width + this.size;
                    if (this.x > canvas.width + this.size) this.x = -this.size * 1.5;
                    if (this.y < -this.size * 1.5) this.y = canvas.height + this.size;
                    if (this.y > canvas.height + this.size) this.y = -this.size * 1.5;
                }
                
                draw() {
                    // Main nebula body
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, 0,
                        this.x, this.y, this.size
                    );
                    gradient.addColorStop(0, this.color.inner);
                    gradient.addColorStop(1, this.color.outer);
                    
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);
                    ctx.translate(-this.x, -this.y);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.ellipse(this.x, this.y, this.size, this.size * 0.7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Nebula highlights
                    for (let i = 0; i < 3; i++) {
                        const highlightSize = this.size * (0.3 + Math.random() * 0.4);
                        const highlightX = this.x + (Math.random() - 0.5) * this.size * 0.8;
                        const highlightY = this.y + (Math.random() - 0.5) * this.size * 0.5;
                        
                        const highlightGradient = ctx.createRadialGradient(
                            highlightX, highlightY, 0,
                            highlightX, highlightY, highlightSize
                        );
                        highlightGradient.addColorStop(0, this.color.highlight);
                        highlightGradient.addColorStop(1, 'rgba(0,0,0,0)');
                        
                        ctx.fillStyle = highlightGradient;
                        ctx.beginPath();
                        ctx.arc(highlightX, highlightY, highlightSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                }
            }

            // Dust particles for depth effect
            class DustParticle {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.size = Math.random() * 2;
                    this.speed = 0.1 + Math.random() * 0.3;
                    this.angle = Math.random() * Math.PI * 2;
                    this.color = `rgba(255, 255, 255, ${Math.random() * 0.05 + 0.02})`;
                }
                
                update() {
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;
                    
                    // Wrap around screen
                    if (this.x < -10) this.x = canvas.width + 10;
                    if (this.x > canvas.width + 10) this.x = -10;
                    if (this.y < -10) this.y = canvas.height + 10;
                    if (this.y > canvas.height + 10) this.y = -10;
                }
                
                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Solar system with enhanced visuals
            const sun = { 
                x: canvas.width / 2, 
                y: canvas.height / 2, 
                radius: 60, 
                coronaSize: 350,
                flareAngle: 0,
                flareSpeed: 0.003,
                pulseSpeed: 0.005,
                pulseFactor: 0,
                surfaceDetails: []
            };
            
            // Create sun surface details
            for (let i = 0; i < 30; i++) {
                sun.surfaceDetails.push({
                    angle: Math.random() * Math.PI * 2,
                    distance: Math.random() * sun.radius * 0.9,
                    size: 1 + Math.random() * 4,
                    speed: 0.01 + Math.random() * 0.02,
                    color: `rgba(255, ${100 + Math.random() * 155}, 0, ${0.7 + Math.random() * 0.3})`
                });
            }

            const planets = [
                { name: "Mercury", radius: 6, distance: 80, speed: 0.03, color: "#C4C4C4", moons: [] },
                { name: "Venus", radius: 9, distance: 120, speed: 0.025, color: "#E8C939", 
                  atmosphere: { size: 12, color: "rgba(232, 201, 57, 0.3)" }, moons: [] },
                { 
                    name: "Earth", 
                    radius: 11, 
                    distance: 170, 
                    speed: 0.02, 
                    color: "#3498db", 
                    atmosphere: { size: 14, color: "rgba(52, 152, 219, 0.2)" },
                    moons: [{ radius: 3, distance: 20, speed: 0.08, color: "#DDDDDD" }],
                    ring: null
                },
                { 
                    name: "Mars", 
                    radius: 8, 
                    distance: 220, 
                    speed: 0.015, 
                    color: "#e74c3c", 
                    atmosphere: { size: 10, color: "rgba(231, 76, 60, 0.15)" },
                    moons: [
                        { radius: 2, distance: 12, speed: 0.15, color: "#BBBBBB" },
                        { radius: 2.5, distance: 18, speed: 0.1, color: "#AAAAAA" }
                    ],
                    ring: null
                },
                { 
                    name: "Jupiter", 
                    radius: 24, 
                    distance: 300, 
                    speed: 0.01, 
                    color: "#f39c12", 
                    atmosphere: { size: 30, color: "rgba(243, 156, 18, 0.25)" },
                    moons: [
                        { radius: 4, distance: 30, speed: 0.1, color: "#EEEEEE" },
                        { radius: 3, distance: 40, speed: 0.08, color: "#DDDDDD" },
                        { radius: 2.5, distance: 50, speed: 0.06, color: "#CCCCCC" }
                    ],
                    ring: { inner: 26, outer: 36, color: "rgba(200, 150, 100, 0.4)" }
                },
                { 
                    name: "Saturn", 
                    radius: 22, 
                    distance: 380, 
                    speed: 0.008, 
                    color: "#f1c40f", 
                    atmosphere: { size: 26, color: "rgba(241, 196, 15, 0.3)" },
                    moons: [
                        { radius: 3.5, distance: 30, speed: 0.12, color: "#EEEEEE" },
                        { radius: 2.5, distance: 40, speed: 0.09, color: "#DDDDDD" }
                    ],
                    ring: { 
                        inner: 24, 
                        outer: 42, 
                        colors: [
                            "rgba(210, 180, 140, 0.6)",
                            "rgba(200, 170, 130, 0.4)",
                            "rgba(190, 160, 120, 0.3)"
                        ],
                        gap: 0.2
                    }
                },
                { 
                    name: "Uranus", 
                    radius: 18, 
                    distance: 460, 
                    speed: 0.006, 
                    color: "#1abc9c", 
                    atmosphere: { size: 21, color: "rgba(26, 188, 156, 0.25)" },
                    moons: [
                        { radius: 2.5, distance: 25, speed: 0.15, color: "#CCCCCC" },
                        { radius: 2, distance: 30, speed: 0.12, color: "#BBBBBB" }
                    ],
                    ring: { 
                        inner: 19, 
                        outer: 30, 
                        colors: [
                            "rgba(150, 200, 200, 0.4)",
                            "rgba(140, 190, 190, 0.3)"
                        ],
                        gap: 0.15
                    }
                },
                { 
                    name: "Neptune", 
                    radius: 17, 
                    distance: 540, 
                    speed: 0.004, 
                    color: "#3498db", 
                    atmosphere: { size: 20, color: "rgba(52, 152, 219, 0.25)" },
                    moons: [
                        { radius: 3, distance: 22, speed: 0.2, color: "#DDDDDD" },
                        { radius: 2.5, distance: 30, speed: 0.15, color: "#CCCCCC" }
                    ],
                    ring: { 
                        inner: 18, 
                        outer: 26, 
                        colors: [
                            "rgba(100, 150, 200, 0.3)",
                            "rgba(90, 140, 190, 0.2)"
                        ],
                        gap: 0.1
                    }
                }
            ];

            let angles = new Array(planets.length).fill(0);
            let moonAngles = planets.map(p => p.moons ? new Array(p.moons.length).fill(0) : []);

            function createStars() {
                stars.length = 0;
                for (let i = 0; i < galaxy.arms * galaxy.starsPerArm; i++) {
                    stars.push(new Star());
                }
                
                // Add some random stars outside the galaxy
                for (let i = 0; i < 400; i++) {
                    const star = new Star();
                    star.x = Math.random() * canvas.width;
                    star.y = Math.random() * canvas.height;
                    star.originalX = star.x - canvas.width/2;
                    star.originalY = star.y - canvas.height/2;
                    stars.push(star);
                }
            }

            function createShootingStars() {
                shootingStars.length = 0;
                for (let i = 0; i < 6; i++) {
                    shootingStars.push(new ShootingStar());
                }
            }

            function createNebulas() {
                nebulas.length = 0;
                for (let i = 0; i < numNebulas; i++) {
                    nebulas.push(new Nebula());
                }
            }
            
            function createDustParticles() {
                dustParticles.length = 0;
                for (let i = 0; i < numDustParticles; i++) {
                    dustParticles.push(new DustParticle());
                }
            }

            function drawSun() {
                // Sun pulse effect
                sun.pulseFactor = 0.9 + 0.1 * Math.sin(now() * sun.pulseSpeed);
                
                // Sun corona (outer glow)
                let gradient = ctx.createRadialGradient(
                    sun.x, sun.y, sun.radius * 0.8, 
                    sun.x, sun.y, sun.coronaSize * sun.pulseFactor
                );
                gradient.addColorStop(0, "rgba(255, 255, 100, 0.8)");
                gradient.addColorStop(0.3, "rgba(255, 150, 50, 0.5)");
                gradient.addColorStop(0.6, "rgba(255, 80, 0, 0.3)");
                gradient.addColorStop(1, "rgba(255, 0, 0, 0)");
                
                ctx.beginPath();
                ctx.arc(sun.x, sun.y, sun.coronaSize * sun.pulseFactor, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Sun surface
                gradient = ctx.createRadialGradient(
                    sun.x, sun.y, 0, 
                    sun.x, sun.y, sun.radius * sun.pulseFactor
                );
                gradient.addColorStop(0, "#FFFF80");
                gradient.addColorStop(0.5, "#FFB347");
                gradient.addColorStop(0.8, "#FF6B35");
                gradient.addColorStop(1, "#FF4500");
                
                ctx.beginPath();
                ctx.arc(sun.x, sun.y, sun.radius * sun.pulseFactor, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Sun flares
                sun.flareAngle += sun.flareSpeed;
                for (let i = 0; i < 12; i++) {
                    const angle = sun.flareAngle + i * (Math.PI / 6);
                    const flareLength = sun.radius * (1.8 + Math.sin(now() * 0.001 + i) * 0.5);
                    const flareWidth = 3 + Math.sin(now() * 0.0015 + i) * 1.5;
                    
                    ctx.strokeStyle = `rgba(255, ${200 + Math.sin(now() * 0.002) * 55}, 50, ${
                        0.4 + Math.sin(now() * 0.003 + i) * 0.2
                    })`;
                    ctx.lineWidth = flareWidth;
                    ctx.beginPath();
                    ctx.moveTo(
                        sun.x + sun.radius * 0.8 * Math.cos(angle),
                        sun.y + sun.radius * 0.8 * Math.sin(angle)
                    );
                    ctx.lineTo(
                        sun.x + (sun.radius + flareLength) * Math.cos(angle),
                        sun.y + (sun.radius + flareLength) * Math.sin(angle)
                    );
                    ctx.stroke();
                }
                
                // Sun surface details
                ctx.save();
                ctx.translate(sun.x, sun.y);
                
                sun.surfaceDetails.forEach(detail => {
                    detail.angle += detail.speed;
                    const x = detail.distance * Math.cos(detail.angle);
                    const y = detail.distance * Math.sin(detail.angle);
                    
                    ctx.fillStyle = detail.color;
                    ctx.beginPath();
                    ctx.arc(x, y, detail.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.restore();
            }

            function drawOrbits() {
                ctx.strokeStyle = "rgba(150, 150, 255, 0.15)";
                ctx.lineWidth = 1;

                for (let i = 0; i < planets.length; i++) {
                    ctx.beginPath();
                    ctx.arc(sun.x, sun.y, planets[i].distance, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Add subtle glow to orbits
                    const gradient = ctx.createRadialGradient(
                        sun.x, sun.y, planets[i].distance - 2,
                        sun.x, sun.y, planets[i].distance + 2
                    );
                    gradient.addColorStop(0, "rgba(100, 100, 255, 0)");
                    gradient.addColorStop(0.5, "rgba(150, 150, 255, 0.1)");
                    gradient.addColorStop(1, "rgba(100, 100, 255, 0)");
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(sun.x, sun.y, planets[i].distance, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            function drawPlanets() {
                for (let i = 0; i < planets.length; i++) {
                    const planet = planets[i];
                    angles[i] += planet.speed;
                    const x = sun.x + planet.distance * Math.cos(angles[i]);
                    const y = sun.y + planet.distance * Math.sin(angles[i]);

                    // Draw planet
                    const gradient = ctx.createRadialGradient(
                        x - planet.radius * 0.3, y - planet.radius * 0.3, 
                        0, 
                        x, y, planet.radius
                    );
                    gradient.addColorStop(0, planet.color);
                    gradient.addColorStop(1, shadeColor(planet.color, -30));
                    
                    ctx.beginPath();
                    ctx.arc(x, y, planet.radius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Draw atmosphere if it has one
                    if (planet.atmosphere) {
                        const atmosphereGradient = ctx.createRadialGradient(
                            x, y, planet.radius,
                            x, y, planet.atmosphere.size
                        );
                        atmosphereGradient.addColorStop(0, planet.color);
                        atmosphereGradient.addColorStop(1, planet.atmosphere.color);
                        
                        ctx.beginPath();
                        ctx.arc(x, y, planet.atmosphere.size, 0, Math.PI * 2);
                        ctx.fillStyle = atmosphereGradient;
                        ctx.fill();
                    }
                    
                    // Draw planet ring if it has one
                    if (planet.ring) {
                        if (planet.ring.colors) {
                            // Multi-colored rings (for gas giants)
                            const ringWidth = planet.ring.outer - planet.ring.inner;
                            const segmentWidth = ringWidth / planet.ring.colors.length;
                            
                            for (let j = 0; j < planet.ring.colors.length; j++) {
                                const inner = planet.ring.inner + j * segmentWidth;
                                const outer = inner + segmentWidth * (1 - (planet.ring.gap || 0));
                                
                                ctx.strokeStyle = planet.ring.colors[j];
                                ctx.lineWidth = outer - inner;
                                ctx.beginPath();
                                ctx.arc(x, y, (inner + outer) / 2, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                        } else {
                            // Simple single-color ring
                            ctx.strokeStyle = planet.ring.color;
                            ctx.lineWidth = planet.ring.outer - planet.ring.inner;
                            ctx.beginPath();
                            ctx.arc(x, y, (planet.ring.inner + planet.ring.outer) / 2, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    }

                    drawMoons(i, x, y);
                }
            }
            
            function shadeColor(color, percent) {
                // Helper function to darken/lighten colors
                let R = parseInt(color.substring(1,3), 16);
                let G = parseInt(color.substring(3,5), 16);
                let B = parseInt(color.substring(5,7), 16);

                R = parseInt(R * (100 + percent) / 100);
                G = parseInt(G * (100 + percent) / 100);
                B = parseInt(B * (100 + percent) / 100);

                R = (R<255)?R:255;  
                G = (G<255)?G:255;  
                B = (B<255)?B:255;  

                R = Math.round(R);
                G = Math.round(G);
                B = Math.round(B);

                const RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
                const GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
                const BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));

                return "#"+RR+GG+BB;
            }

            function drawMoons(planetIndex, planetX, planetY) {
                const planet = planets[planetIndex];
                if (!planet.moons) return;
                
                for (let j = 0; j < planet.moons.length; j++) {
                    const moon = planet.moons[j];
                    moonAngles[planetIndex][j] += moon.speed;
                    const mx = planetX + moon.distance * Math.cos(moonAngles[planetIndex][j]);
                    const my = planetY + moon.distance * Math.sin(moonAngles[planetIndex][j]);

                    // Moon shadow effect
                    ctx.fillStyle = `rgba(0, 0, 0, 0.2)`;
                    ctx.beginPath();
                    ctx.arc(
                        mx + moon.radius * 0.3, 
                        my + moon.radius * 0.3, 
                        moon.radius, 0, Math.PI * 2
                    );
                    ctx.fill();
                    
                    // Moon surface
                    const gradient = ctx.createRadialGradient(
                        mx - moon.radius * 0.2, my - moon.radius * 0.2, 
                        0, 
                        mx, my, moon.radius
                    );
                    gradient.addColorStop(0, moon.color);
                    gradient.addColorStop(1, shadeColor(moon.color, -20));
                    
                    ctx.beginPath();
                    ctx.arc(mx, my, moon.radius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Moon glow
                    ctx.beginPath();
                    ctx.arc(mx, my, moon.radius * 1.8, 0, Math.PI * 2);
                    ctx.fillStyle = moon.color.replace(/[\d\.]+\)$/, '0.15)');
                    ctx.fill();
                }
            }

            function animate(timestamp) {
                // Optimized animation loop
                requestAnimationFrame(animate);
                
                const now = timestamp || performance.now();
                const elapsed = now - lastTime;
                
                if (elapsed > fpsInterval) {
                    lastTime = now - (elapsed % fpsInterval);
                    
                    // Clear with a slight fade to create motion trails
                    ctx.fillStyle = "rgba(0, 0, 15, 0.08)";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw dust particles first (background)
                    dustParticles.forEach(particle => {
                        particle.update();
                        particle.draw();
                    });
                    
                    // Draw nebulas
                    nebulas.forEach(nebula => {
                        nebula.update();
                        nebula.draw();
                    });
                    
                    // Update and draw stars
                    stars.forEach(star => {
                        star.update();
                        star.draw();
                    });
                    
                    // Draw shooting stars
                    shootingStars.forEach(star => {
                        star.update();
                        star.draw();
                    });

                    // Draw solar system
                    drawOrbits();
                    drawPlanets();
                    drawSun();
                }
            }

            window.addEventListener("resize", () => {
                resizeCanvas();
                createStars();
                createShootingStars();
                createNebulas();
                createDustParticles();
            });

            // Initialize everything
            createStars();
            createShootingStars();
            createNebulas();
            createDustParticles();
            animate();
        }
    </script>

    <script src="https://cdn.aryanaryal.com.np/626c6f672d617279616e/6d61696e/6a73/16234.js"></script>

</body>
</html>
